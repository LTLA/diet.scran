% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/initializeSparseMatrix.R
\name{initializeSparseMatrix}
\alias{initializeSparseMatrix}
\title{Initialize the count matrix}
\usage{
initializeSparseMatrix(
  x,
  force.integer = TRUE,
  no.sparse.copy = TRUE,
  by.column = TRUE,
  num.threads = 1
)
}
\arguments{
\item{x}{A matrix-like object.
This should contain non-negative integers.}

\item{force.integer}{Logical scalar indicating whether double-precision \code{x} should be forced into integers.}

\item{no.sparse.copy}{Logical scalar indicating whether we should avoid a copy when \code{x} is a dgCMatrix.
This is more memory efficient if the data has already been loaded into memory.
If \code{TRUE}, any setting of \code{force.integer} is ignored.}

\item{num.threads}{Integer scalar specifying the number of threads to use when initializing \code{x}.
For dgCMatrix inputs, this is only relevant when \code{no.sparse.copy = FALSE}.}
}
\value{
A list of internal components that can be used in other \pkg{scran.chan} functions.
}
\description{
Initialize a matrix object on the C++ side.
If the input is a \linkS4class{dgCMatrix}, initialization is performed without copying any data;
otherwise an efficient block realization is performed.
}
\details{
Do not attempt to serialize this object; it contains a pointer to external memory, and will not be valid after a save/load cycle.

If \code{no.sparse.copy=TRUE}, the lifetime of the sparse matrix in \code{x} must be greater than the returned pointer.
}
\examples{
# Mocking up a count matrix:
x <- Matrix::rsparsematrix(1000, 100, 0.1)
y <- round(abs(x))

stuff <- initializeSparseMatrix(y)
str(stuff)

# Trying with a DelayedArray:
z <- DelayedArray::DelayedArray(y)
stuff2 <- initializeSparseMatrix(z)
str(stuff2)

# Row-major initialization:
stuff2 <- initializeSparseMatrix(z, by.column=FALSE)
str(stuff2)

}
